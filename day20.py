'''
Advent of Code 2020, Day 20.
James Jolley, jim.jolley [at] gmail.com
'''

import numpy as np

def load_tiles(path):
    '''
    Returns dict of 10x10 tiles, keyed by tile number. Tiles are sequences
    of 10 ints, where 0-bits represent the (.) character and 1-bits represent
    the (#) character.
    '''
    tiles = {}
    with open(path) as file:
        lines = file.readlines()
    while len(lines) > 0:
        num = int(lines[0][5:].split(':')[0])
        tile = [int(line.replace('.','0').replace('#','1'),2) for line in lines[1:11]]
        tiles[num] = tile
        del lines[:12]
    return tiles

def rotate_tile(tile):
    '''
    Return a copy of the tile rotated 90 degrees clockwise.
    '''
    new_tile = []
    for twoexp in range(9, -1, -1):
        value = 0
        for row in range(9, -1, -1):
            value *= 2
            value += ((tile[row]//(2**twoexp))%2)
        new_tile.append(value)
    return new_tile

def get_edge_values(tile):
    '''
    Return a sequence of the values along the edges of the tile. The
    sequence will contain 4 values, representing the top, right, bottom,
    and left edges respectively. Top and bottom edges are read left-to-right;
    left and right edges are read top-to-bottom.
    '''
    left, right = 0, 0
    for value in tile:
        left *= 2
        right *= 2
        left += ((value//(2**9))%2)
        right += (value%2)
    return [tile[0], right, tile[-1], left]

def all_edge_values(tiles):
    '''
    Returns all edge values found in all rotations of all tiles. Edge values
    are keys in the returned dict, mapping to lists of tuples where the value
    is found. Tuples contain the tile number, the number of rotations applied
    to the tile (0 to 3 inclusive), and the edge where value was found --
    0 is top, 1 is right, 2 is bottom, 3 is left.
    '''
    edge_values = {}
    for rot in range(4):
        for num, tile in tiles.items():
            edges = get_edge_values(tile)
            for i in range(len(edges)):
                if edges[i] in edge_values:
                    edge_values[edges[i]].append((num,rot,i))
                else:
                    edge_values[edges[i]] = [(num,rot,i)]
        if rot != 3:
            tiles = {num:rotate_tile(tile) for num,tile in tiles.items()}
    return edge_values

def find_corners(edge_values):
    '''
    Find the corner tiles using the dict of edge values generated by
    all_edge_values. Corner tiles will have the fewest numbers of valid
    combinations with other tiles.
    '''
    links = {}
    for value in edge_values.values():
        for i in range(len(value)):
            for j in range(len(value)):
                if i!=j and value[i][0] != value[j][0]:
                    if value[i][0] in links:
                        links[value[i][0]] += 1
                    else:
                        links[value[i][0]] = 1
    links = [(k,v) for k,v in links.items()]
    links.sort(key=lambda t:(t[1],t[0]))
    return [link[0] for link in links[:4]]

if __name__ == '__main__':
    # part 1
    tiles = load_tiles('input/day20.txt')
    corners = find_corners(all_edge_values(tiles))
    print(np.prod(corners))
    
